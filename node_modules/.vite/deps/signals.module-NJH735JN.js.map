{
  "version": 3,
  "sources": ["../../@preact/signals-core/src/index.ts", "../../@preact/signals/src/index.ts"],
  "sourcesContent": ["function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t// `signal` is a new dependency. Create a new node dependency node, move it\n\t\t//  to the front of the current context's dependency list.\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: undefined,\n\t\t\t_nextSource: evalContext._sources,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t// If `node` is not already the current head of the dependency list (i.e.\n\t\t// there is a previous node in the list), then make `node` the new head.\n\t\tif (node._prevSource !== undefined) {\n\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = node._prevSource;\n\t\t\t}\n\t\t\tnode._prevSource = undefined;\n\t\t\tnode._nextSource = evalContext._sources;\n\t\t\t// evalCotext._sources must be !== undefined (and !== node), because\n\t\t\t// `node` was originally pointing to some previous node.\n\t\t\tevalContext._sources!._prevSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/** @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable notes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\tpeek(): T;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\tconst prev = node._prevTarget;\n\tconst next = node._nextTarget;\n\tif (prev !== undefined) {\n\t\tprev._nextTarget = next;\n\t\tnode._prevTarget = undefined;\n\t}\n\tif (next !== undefined) {\n\t\tnext._prevTarget = prev;\n\t\tnode._nextTarget = undefined;\n\t}\n\tif (node === this._targets) {\n\t\tthis._targets = next;\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then the\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\t// At this point target._sources is a mishmash of current & former dependencies.\n\t// The current dependencies are also in a reverse order of use.\n\t// Therefore build a new, reverted list of dependencies containing only the current\n\t// dependencies in a proper order of use.\n\t// Drop former dependencies from the list and unsubscribe from their change notifications.\n\n\tlet node = target._sources;\n\tlet sources = undefined;\n\twhile (node !== undefined) {\n\t\tconst next = node._nextSource;\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\t\t\tnode._nextSource = undefined;\n\t\t} else {\n\t\t\tif (sources !== undefined) {\n\t\t\t\tsources._prevSource = node;\n\t\t\t}\n\t\t\tnode._prevSource = undefined;\n\t\t\tnode._nextSource = sources;\n\t\t\tsources = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\t\tnode = next;\n\t}\n\ttarget._sources = sources;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNIN flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\tSignal.prototype._unsubscribe.call(this, node);\n\n\t// Computed signal unsubscribes from its dependencies from it loses its last subscriber.\n\tif (this._targets === undefined) {\n\t\tthis._flags &= ~TRACKING;\n\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._unsubscribe(node);\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._compute = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ndeclare class Effect {\n\t_compute?: () => unknown;\n\t_cleanup?: unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => void);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => void) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (!(this._flags & DISPOSED) && this._compute !== undefined) {\n\t\t\tthis._cleanup = this._compute();\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown): () => void {\n\tconst effect = new Effect(compute);\n\teffect._callback();\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { signal, computed, effect, batch, Signal, ReadonlySignal };\n", "import { options, Component } from \"preact\";\nimport { useRef, useMemo, useEffect } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport { signal, computed, batch, effect, Signal, type ReadonlySignal };\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction Text(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst s = useMemo(() => {\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Replace this component's vdom updater with a direct text one:\n\t\tthis._updater!._callback = () => {\n\t\t\t(this.base as Text).data = s.peek();\n\t\t};\n\n\t\treturn computed(() => {\n\t\t\tlet data = currentSignal.value;\n\t\t\tlet s = data.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\t}, []);\n\n\treturn s.value;\n}\nText.displayName = \"_st\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true },\n\ttype: { configurable: true, value: Text },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tsetCurrentUpdater();\n\n\tlet updater;\n\n\tlet component = vnode.__c;\n\tif (component) {\n\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\tupdater = component._updater;\n\t\tif (updater === undefined) {\n\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tcomponent.setState({});\n\t\t\t});\n\t\t}\n\t}\n\n\tcurrentComponent = component;\n\tsetCurrentUpdater(updater);\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(() => {\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// let reason;\n\t// if (!hasSignals && !hasComputeds.has(this)) {\n\t// \treason = \"no signals or computeds\";\n\t// } else if (hasPendingUpdate.has(this)) {\n\t// \treason = \"has pending update\";\n\t// } else if (hasHookState.has(this)) {\n\t// \treason = \"has hook state\";\n\t// }\n\t// if (reason) {\n\t// \tif (!this) reason += \" (`this` bug)\";\n\t// \tconsole.log(\"not optimizing\", this?.constructor?.name, \": \", reason, {\n\t// \t\tdetails: {\n\t// \t\t\thasSignals,\n\t// \t\t\thasComputeds: hasComputeds.has(this),\n\t// \t\t\thasPendingUpdate: hasPendingUpdate.has(this),\n\t// \t\t\thasHookState: hasHookState.has(this),\n\t// \t\t\tdeps: Array.from(updater._deps),\n\t// \t\t\tupdater,\n\t// \t\t},\n\t// \t});\n\t// }\n\n\t// if this component used no signals or computeds, update:\n\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t// if there is a pending re-render triggered from Signals,\n\t// or if there is hook or class state, update:\n\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), []);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\treturn useMemo(() => computed<T>(() => $compute.current()), []);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => {\n\t\t\tcallback.current();\n\t\t});\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n"],
  "mappings": "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",
  "names": ["cycleDetected", "Error", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "batch", "callback", "evalContext", "globalVersion", "addDependency", "signal", "node", "_node", "_target", "_sources", "_version", "_source", "_prevSource", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "_refresh", "_unsubscribe", "prev", "subscribe", "fn", "flag", "valueOf", "toString", "peek", "Object", "defineProperty", "get", "set", "_notify", "target", "prepareSources", "rollbackNode", "cleanupSources", "sources", "Computed", "compute", "call", "undefined", "_compute", "_globalVersion", "prevContext", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "finish", "_start", "bind", "_dispose", "currentComponent", "hook", "hookName", "hookFn", "options", "bind", "setCurrentUpdater", "updater", "finishUpdate", "_start", "Text", "_ref", "data", "currentSignal", "useSignal", "value", "s", "useMemo", "v", "_this", "__v", "__", "__c", "_updateFlags", "_updater", "_callback", "base", "peek", "computed", "n", "displayName", "Object", "defineProperties", "Signal", "prototype", "constructor", "configurable", "type", "props", "get", "this", "__b", "old", "vnode", "signalProps", "i", "e", "__np", "component", "update", "effect", "setState", "createUpdater", "error", "oldVNode", "dom", "__e", "renderedProps", "updaters", "_updaters", "prop", "_dispose", "signal", "createPropUpdater", "_update", "propSignal", "setAsProperty", "ownerSVGElement", "changeSignal", "newSignal", "newProps", "setAttribute", "removeAttribute", "o", "index", "Component", "shouldComponentUpdate", "state", "_sources", "HAS_PENDING_UPDATE", "useComputed", "compute", "$compute", "useRef", "current", "useSignalEffect", "cb", "callback", "useEffect"]
}
